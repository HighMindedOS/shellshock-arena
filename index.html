<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shellshock Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* Canvas Styles */
        #canvas {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            cursor: none;
            background: #1a1a1a;
        }

        #fogCanvas {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }

        /* Menu Container */
        #menuContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Sidebars */
        .sidebar {
            position: absolute;
            top: 0;
            height: 100vh;
            width: 350px;
            background: linear-gradient(180deg, rgba(20,20,20,0.95) 0%, rgba(10,10,10,0.95) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 40px;
            color: white;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
        }

        .sidebar-left {
            left: 0;
            transform: translateX(-100%);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-right {
            right: 0;
            transform: translateX(100%);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar.active {
            transform: translateX(0);
        }

        /* Menu Title */
        .menu-title {
            text-align: center;
            margin-bottom: 40px;
        }

        .menu-title h1 {
            font-size: 42px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #ff0000 0%, #ff6600 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
        }

        .menu-title h2 {
            font-size: 16px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Menu Sections */
        .menu-section {
            margin: 30px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .menu-section h3 {
            margin-bottom: 15px;
            color: #ff6600;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 14px;
        }

        /* Input Fields */
        input[type="text"] {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 16px;
            transition: all 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #ff6600;
            background: rgba(255, 255, 255, 0.1);
        }

        /* Connection Status */
        #connectionStatus {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-connected {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
            border: 1px solid #4CAF50;
        }

        .status-disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid #f44336;
        }

        .status-connecting {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
            border: 1px solid #FF9800;
        }

        /* Custom Button Style */
        .game-button {
            width: 100%;
            margin: 10px 0;
            padding: 20px 60px;
            background-color: #000;
            border: none;
            font-size: 18px;
            position: relative;
            transition: 500ms;
            cursor: pointer;
            overflow: visible;
        }

        .game-button span {
            color: gray;
            position: relative;
            transition: 500ms;
            transition-delay: 500ms;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
        }

        .game-button:before {
            content: '';
            position: absolute;
            width: 0%;
            height: 0%;
            left: 50%;
            right: 50%;
            top: 50%;
            bottom: 50%;
            transition: 500ms;
            transition-delay: 500ms;
            background-color: red;
            box-shadow: 0 0 10px red, 0 0 30px red, 0 0 50px red;
        }

        .game-button div {
            transition: 500ms;
            position: absolute;
            background-color: red;
            box-shadow: 0 0 15px red, 0 0 30px red, 0 0 50px red;
        }

        .game-button .top {
            width: 15px;
            height: 2px;
            top: 0;
            left: 0;
        }

        .game-button .bottom {
            width: 15px;
            height: 2px;
            bottom: 0;
            right: 0;
        }

        .game-button .left {
            width: 2px;
            height: 15px;
            top: 0;
            left: 0;
        }

        .game-button .right {
            width: 2px;
            height: 15px;
            bottom: 0;
            right: 0;
        }

        .game-button:hover {
            color: #000;
        }

        .game-button:hover span {
            color: #000;
        }

        .game-button:hover:before {
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .game-button:hover .top, 
        .game-button:hover .bottom {
            width: 100%;
        }

        .game-button:hover .left,
        .game-button:hover .right {
            height: 100%;
        }

        /* Game UI */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            display: none;
        }

        /* Game Sidebar */
        .game-sidebar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100vh;
            width: 300px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
            border-right: 1px solid rgba(255, 0, 0, 0.3);
            padding: 20px;
            transform: translateX(-100%);
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .game-sidebar.active {
            transform: translateX(0);
        }

        /* Player Stats */
        .player-stats {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 0, 0, 0.2);
            color: white;
        }

        .player-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ff6600;
        }

        .health-bar {
            width: 100%;
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin: 5px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }

        .points-display {
            font-size: 20px;
            font-weight: bold;
            color: #ffd700;
            margin-top: 10px;
            text-align: center;
        }

        /* Powerups */
        .powerup-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .powerup-item {
            height: 70px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 0, 0, 0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            padding: 10px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .powerup-item.available {
            border-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        .powerup-item.available:after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, transparent, #ff0000, transparent);
            animation: rotate 2s linear infinite;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .powerup-item.used {
            opacity: 0.3;
            filter: grayscale(100%);
        }

        .powerup-key {
            font-size: 32px;
            font-weight: bold;
            color: white;
            width: 50px;
            text-align: center;
        }

        .powerup-info {
            flex: 1;
            padding-left: 10px;
        }

        .powerup-name {
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-transform: uppercase;
        }

        .powerup-cost {
            font-size: 12px;
            color: #ffd700;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 0, 0, 0.3);
            border-radius: 10px;
        }

        /* Countdown */
        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
            display: none;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        /* After Game Screen */
        #afterGameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #afterGameOverlay.active {
            display: block;
            opacity: 1;
        }

        #afterGameScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: linear-gradient(135deg, rgba(20,20,20,0.98) 0%, rgba(10,10,10,0.98) 100%);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(255, 0, 0, 0.3);
            color: white;
            min-width: 700px;
            max-width: 900px;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 100px rgba(255, 0, 0, 0.3);
        }

        #afterGameOverlay.active #afterGameScreen {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        #gameResult {
            font-size: 64px;
            text-align: center;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        .victory {
            color: #4CAF50;
            text-shadow: 0 0 50px rgba(76, 175, 80, 0.8);
        }

        .defeat {
            color: #f44336;
            text-shadow: 0 0 50px rgba(244, 67, 54, 0.8);
        }

        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }

        .player-stats-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 0, 0, 0.2);
        }

        .player-stats-card h3 {
            margin-bottom: 15px;
            font-size: 20px;
            color: #ff6600;
            text-transform: uppercase;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.6);
        }

        .stat-value {
            font-weight: bold;
            color: white;
        }

        .button-row {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }

        /* Error Toast */
        .error-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(244, 67, 54, 0.95);
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            animation: slideIn 0.3s ease;
            z-index: 10000;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <canvas id="fogCanvas"></canvas>
    
    <div id="menuContainer">
        <!-- Left Sidebar -->
        <div class="sidebar sidebar-left" id="leftSidebar">
            <div class="menu-title">
                <h1>SHELLSHOCK</h1>
                <h2>Arena Combat</h2>
            </div>
            
            <div id="connectionStatus" class="status-disconnected">
                Nicht verbunden
            </div>

            <div class="menu-section">
                <h3>Spielername</h3>
                <input type="text" id="playerName" placeholder="Dein Name" maxlength="20">
            </div>

            <div class="menu-section">
                <h3>Spiel erstellen</h3>
                <button class="game-button" id="createLobby">
                    <div class="top"></div>
                    <div class="bottom"></div>
                    <div class="left"></div>
                    <div class="right"></div>
                    <span>Neue Lobby</span>
                </button>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div class="sidebar sidebar-right" id="rightSidebar">
            <div class="menu-section">
                <h3>Spiel beitreten</h3>
                <input type="text" id="lobbyCode" placeholder="Lobby-Code eingeben">
                <button class="game-button" id="joinLobby">
                    <div class="top"></div>
                    <div class="bottom"></div>
                    <div class="left"></div>
                    <div class="right"></div>
                    <span>Beitreten</span>
                </button>
            </div>

            <div class="menu-section">
                <h3>Offene Lobbys</h3>
                <div id="lobbyList"></div>
                <button class="game-button" id="refreshLobbies">
                    <div class="top"></div>
                    <div class="bottom"></div>
                    <div class="left"></div>
                    <div class="right"></div>
                    <span>Aktualisieren</span>
                </button>
            </div>

            <div class="menu-section" id="waitingRoom" style="display: none;">
                <h3>Warte auf Spieler...</h3>
                <p style="margin: 10px 0;">Lobby-Code: <strong id="currentLobbyCode" style="color: #ff6600;"></strong></p>
                <p id="playersInLobby" style="margin: 10px 0;">Spieler: 1/2</p>
                <button class="game-button" id="leaveLobby">
                    <div class="top"></div>
                    <div class="bottom"></div>
                    <div class="left"></div>
                    <div class="right"></div>
                    <span>Verlassen</span>
                </button>
            </div>
        </div>
    </div>

    <div id="gameUI">
        <div class="game-sidebar" id="gameSidebar">
            <div class="player-stats">
                <div class="player-name" id="yourName">Spieler 1</div>
                <div class="health-bar">
                    <div class="health-fill" id="yourHealth" style="width: 100%"></div>
                </div>
                <div class="points-display">
                    ðŸ’° <span id="yourPoints">0</span>
                </div>
            </div>

            <div class="powerup-container">
                <div class="powerup-item" id="powerup1">
                    <div class="powerup-key">1</div>
                    <div class="powerup-info">
                        <div class="powerup-name">LASER</div>
                        <div class="powerup-cost">20 Punkte</div>
                    </div>
                </div>
                <div class="powerup-item" id="powerup2">
                    <div class="powerup-key">2</div>
                    <div class="powerup-info">
                        <div class="powerup-name">EXPLOSION</div>
                        <div class="powerup-cost">20 Punkte</div>
                    </div>
                </div>
                <div class="powerup-item" id="powerup3">
                    <div class="powerup-key">3</div>
                    <div class="powerup-info">
                        <div class="powerup-name">SCHILD</div>
                        <div class="powerup-cost">20 Punkte</div>
                    </div>
                </div>
            </div>
        </div>

        <canvas id="minimap"></canvas>
        <div id="countdown"></div>
    </div>

    <div id="afterGameOverlay">
        <div id="afterGameScreen">
            <h2 id="gameResult">VICTORY!</h2>
            
            <div class="stats-container">
                <div class="player-stats-card">
                    <h3 id="player1Name">Spieler 1</h3>
                    <div class="stat-row">
                        <span class="stat-label">Schaden</span>
                        <span class="stat-value" id="player1Damage">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Erhalten</span>
                        <span class="stat-value" id="player1DamageTaken">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Genauigkeit</span>
                        <span class="stat-value" id="player1Accuracy">0%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">SchÃ¼sse</span>
                        <span class="stat-value" id="player1Shots">0</span>
                    </div>
                </div>

                <div class="player-stats-card">
                    <h3 id="player2Name">Spieler 2</h3>
                    <div class="stat-row">
                        <span class="stat-label">Schaden</span>
                        <span class="stat-value" id="player2Damage">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Erhalten</span>
                        <span class="stat-value" id="player2DamageTaken">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Genauigkeit</span>
                        <span class="stat-value" id="player2Accuracy">0%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">SchÃ¼sse</span>
                        <span class="stat-value" id="player2Shots">0</span>
                    </div>
                </div>
            </div>

            <div class="button-row">
                <button class="game-button" id="rematchBtn">
                    <div class="top"></div>
                    <div class="bottom"></div>
                    <div class="left"></div>
                    <div class="right"></div>
                    <span>Rematch</span>
                </button>
                <button class="game-button" id="newLobbyBtn">
                    <div class="top"></div>
                    <div class="bottom"></div>
                    <div class="left"></div>
                    <div class="right"></div>
                    <span>Neue Lobby</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // Game Configuration
        const config = {
            player: {
                size: 30,
                speed: 250,
                maxHealth: 100,
                reloadTime: 1000,
                acceleration: 800,
                friction: 0.9
            },
            projectile: {
                speed: 600,
                damage: 5,
                size: 5
            },
            powerups: {
                laser: {
                    damage: 15,
                    cost: 20,
                    color: '#00ff00',
                    instant: true
                },
                explosive: {
                    damage: 20,
                    cost: 20,
                    radius: 100,
                    explosionDelay: 400,
                    color: '#ff6600',
                    speed: 450
                },
                shield: {
                    absorption: 20,
                    cost: 20,
                    duration: 10000,
                    color: '#00ccff'
                }
            },
            cover: {
                color: '#444444'
            },
            camera: {
                smoothness: 0.15
            },
            server: {
                url: 'wss://shellshock-arena-production.up.railway.app'
            }
        };

        // Game State
        let gameState = {
            inGame: false,
            gameEnded: false,
            countdownActive: false,
            players: {},
            projectiles: [],
            covers: [],
            explosions: [],
            laserEffects: [],
            shotIndicators: [],
            localPlayerId: null,
            mousePos: { x: 0, y: 0 },
            worldMousePos: { x: 0, y: 0 },
            keys: {},
            lastUpdateTime: Date.now(),
            pendingPowerup: null,
            camera: { x: 0, y: 0, targetX: 0, targetY: 0 },
            arenaSize: { width: 2000, height: 2000 },
            rematchVotes: 0,
            visiblePoints: [],
            playerIndex: 0
        };

        // WebSocket
        let socket = null;
        let reconnectTimeout = null;

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fogCanvas = document.getElementById('fogCanvas');
        const fogCtx = fogCanvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Resize canvases
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            fogCanvas.width = window.innerWidth;
            fogCanvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Initialize
        window.addEventListener('load', () => {
            // Show sidebars with animation
            setTimeout(() => {
                document.getElementById('leftSidebar').classList.add('active');
                document.getElementById('rightSidebar').classList.add('active');
            }, 100);
            
            connectToServer();
        });

        // WebSocket connection
        function connectToServer() {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = 'status-connecting';
            statusEl.textContent = 'Verbinde...';

            try {
                socket = new WebSocket(config.server.url);
                
                socket.onopen = () => {
                    console.log('Connected to server');
                    statusEl.className = 'status-connected';
                    statusEl.textContent = 'Verbunden';

                    const playerName = document.getElementById('playerName').value || 'Spieler';
                    socket.send(JSON.stringify({
                        type: 'setName',
                        name: playerName
                    }));
                };

                socket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleServerMessage(data);
                };

                socket.onclose = () => {
                    statusEl.className = 'status-disconnected';
                    statusEl.textContent = 'Nicht verbunden';
                    
                    if (gameState.inGame && !gameState.gameEnded) {
                        endGame('Verbindung verloren');
                    }
                };

                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.className = 'status-disconnected';
                    statusEl.textContent = 'Verbindungsfehler';
                };
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
            }
        }

        // Handle server messages
        function handleServerMessage(data) {
            switch(data.type) {
                case 'lobbyCreated':
                    showWaitingRoom(data.lobbyCode);
                    break;
                case 'lobbyJoined':
                    showWaitingRoom(data.lobbyCode);
                    break;
                case 'lobbyUpdate':
                    updateWaitingRoom(data);
                    break;
                case 'gameStart':
                    startGame(data);
                    break;
                case 'gameState':
                    updateGameState(data.state);
                    break;
                case 'playerHit':
                    handlePlayerHit(data);
                    break;
                case 'gameOver':
                    handleGameOver(data);
                    break;
                case 'projectileCreated':
                    addProjectile(data.projectile);
                    break;
                case 'instantProjectile':
                    handleInstantProjectile(data.projectile);
                    break;
                case 'powerupConfirmed':
                    handlePowerupConfirmed(data);
                    break;
                case 'rematchVote':
                    updateRematchVotes(data);
                    break;
                case 'error':
                    showError(data.message);
                    break;
            }
        }

        // UI Functions
        function showWaitingRoom(lobbyCode) {
            document.getElementById('currentLobbyCode').textContent = lobbyCode;
            document.getElementById('waitingRoom').style.display = 'block';
        }

        function updateWaitingRoom(data) {
            document.getElementById('playersInLobby').textContent = `Spieler: ${data.players}/2`;
        }

        function showError(message) {
            const toast = document.createElement('div');
            toast.className = 'error-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Game Functions
        function startGame(data) {
            // Hide menu sidebars
            document.getElementById('leftSidebar').classList.remove('active');
            document.getElementById('rightSidebar').classList.remove('active');

            // Initialize game state
            gameState = {
                inGame: true,
                gameEnded: false,
                countdownActive: true,
                players: {},
                projectiles: [],
                covers: data.covers || [],
                explosions: [],
                laserEffects: [],
                shotIndicators: [],
                localPlayerId: data.localPlayer.id,
                mousePos: { x: 0, y: 0 },
                worldMousePos: { x: 0, y: 0 },
                keys: {},
                lastUpdateTime: Date.now(),
                pendingPowerup: null,
                camera: { x: 0, y: 0, targetX: 0, targetY: 0 },
                arenaSize: data.arenaSize || { width: 2000, height: 2000 },
                rematchVotes: 0,
                visiblePoints: [],
                playerIndex: data.localPlayer.playerIndex || 0
            };

            // Transform coordinates for mirrored perspective
            const transformCoords = gameState.playerIndex === 1;
            
            // Initialize players with transformed positions
            gameState.players[data.localPlayer.id] = {
                ...data.localPlayer,
                x: transformCoords ? gameState.arenaSize.width - data.localPlayer.x : data.localPlayer.x,
                y: transformCoords ? gameState.arenaSize.height - data.localPlayer.y : data.localPlayer.y,
                rotation: transformCoords ? data.localPlayer.rotation + Math.PI : data.localPlayer.rotation,
                isLocal: true,
                usedPowerups: new Set(data.localPlayer.usedPowerups || [])
            };
            
            gameState.players[data.enemyPlayer.id] = {
                ...data.enemyPlayer,
                x: transformCoords ? gameState.arenaSize.width - data.enemyPlayer.x : data.enemyPlayer.x,
                y: transformCoords ? gameState.arenaSize.height - data.enemyPlayer.y : data.enemyPlayer.y,
                rotation: transformCoords ? data.enemyPlayer.rotation + Math.PI : data.enemyPlayer.rotation,
                isLocal: false,
                usedPowerups: new Set(),
                visible: false
            };

            // Transform covers if needed
            if (transformCoords) {
                gameState.covers = gameState.covers.map(cover => ({
                    ...cover,
                    x: gameState.arenaSize.width - cover.x - cover.width,
                    y: gameState.arenaSize.height - cover.y - cover.height
                }));
            }

            // Set initial camera
            const localPlayer = gameState.players[data.localPlayer.id];
            gameState.camera = {
                x: localPlayer.x,
                y: localPlayer.y,
                targetX: localPlayer.x,
                targetY: localPlayer.y
            };

            // Show game UI
            setTimeout(() => {
                document.getElementById('menuContainer').style.display = 'none';
                document.getElementById('canvas').style.display = 'block';
                document.getElementById('fogCanvas').style.display = 'block';
                document.getElementById('gameUI').style.display = 'block';
                
                // Slide in game sidebar
                setTimeout(() => {
                    document.getElementById('gameSidebar').classList.add('active');
                }, 100);

                // Start countdown
                startCountdown();
            }, 600);

            document.getElementById('yourName').textContent = data.localPlayer.name;
            updateUI();
        }

        function startCountdown() {
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            let count = 5;

            const countInterval = setInterval(() => {
                countdownEl.textContent = count;
                count--;
                
                if (count < 0) {
                    clearInterval(countInterval);
                    countdownEl.style.display = 'none';
                    gameState.countdownActive = false;
                    gameLoop();
                }
            }, 1000);
        }

        function updateGameState(state) {
            if (!gameState.inGame) return;

            const transformCoords = gameState.playerIndex === 1;

            // Update visible points for fog of war
            if (state.visiblePoints) {
                gameState.visiblePoints = transformCoords ? 
                    state.visiblePoints.map(p => ({
                        x: gameState.arenaSize.width - p.x,
                        y: gameState.arenaSize.height - p.y
                    })) : state.visiblePoints;
            }

            // Update players
            if (state.players) {
                Object.entries(state.players).forEach(([id, playerData]) => {
                    if (gameState.players[id]) {
                        const isLocal = gameState.players[id].isLocal;
                        
                        // Transform coordinates if needed
                        const x = transformCoords ? gameState.arenaSize.width - playerData.x : playerData.x;
                        const y = transformCoords ? gameState.arenaSize.height - playerData.y : playerData.y;
                        const rotation = transformCoords ? playerData.rotation + Math.PI : playerData.rotation;
                        
                        gameState.players[id] = {
                            ...gameState.players[id],
                            ...playerData,
                            x: playerData.visible !== false ? x : gameState.players[id].x,
                            y: playerData.visible !== false ? y : gameState.players[id].y,
                            rotation: playerData.visible !== false ? rotation : gameState.players[id].rotation,
                            isLocal: isLocal,
                            id: id,
                            usedPowerups: new Set(playerData.usedPowerups || [])
                        };
                    }
                });
            }

            // Update projectiles
            if (state.projectiles) {
                state.projectiles.forEach(serverProj => {
                    if (!gameState.projectiles.find(p => p.id === serverProj.id)) {
                        gameState.projectiles.push({
                            ...serverProj,
                            x: transformCoords ? gameState.arenaSize.width - serverProj.x : serverProj.x,
                            y: transformCoords ? gameState.arenaSize.height - serverProj.y : serverProj.y,
                            vx: transformCoords ? -serverProj.vx : serverProj.vx,
                            vy: transformCoords ? -serverProj.vy : serverProj.vy
                        });
                    }
                });
            }

            // Handle explosions
            if (state.explosions) {
                state.explosions.forEach(explosion => {
                    gameState.explosions.push({
                        ...explosion,
                        x: transformCoords ? gameState.arenaSize.width - explosion.x : explosion.x,
                        y: transformCoords ? gameState.arenaSize.height - explosion.y : explosion.y,
                        startTime: Date.now(),
                        duration: 500
                    });
                });
            }

            updateUI();
        }

        function handlePlayerHit(data) {
            const hitPlayer = gameState.players[data.playerId];
            const attacker = gameState.players[data.attackerId];
            
            if (hitPlayer) {
                hitPlayer.health = data.health;
            }
            
            if (attacker && data.attackerId === gameState.localPlayerId) {
                attacker.points = data.attackerPoints;
            }
            
            updateUI();
        }

        function handleGameOver(data) {
            if (gameState.gameEnded) return;
            
            gameState.gameEnded = true;
            gameState.inGame = false;
            
            // Hide game sidebar
            document.getElementById('gameSidebar').classList.remove('active');
            
            // Show after game screen with animation
            setTimeout(() => {
                showAfterGameScreen(data);
            }, 600);
        }

        function showAfterGameScreen(data) {
            const isVictory = data.winner === gameState.localPlayerId;
            const resultEl = document.getElementById('gameResult');
            resultEl.textContent = isVictory ? 'VICTORY!' : 'DEFEAT';
            resultEl.className = isVictory ? 'victory' : 'defeat';
            
            // Fill statistics
            if (data.statistics) {
                let playerIndex = 1;
                Object.entries(data.statistics).forEach(([playerId, stats]) => {
                    const player = gameState.players[playerId];
                    if (player) {
                        document.getElementById(`player${playerIndex}Name`).textContent = player.name;
                        document.getElementById(`player${playerIndex}Damage`).textContent = stats.totalDamageDealt || 0;
                        document.getElementById(`player${playerIndex}DamageTaken`).textContent = stats.totalDamageTaken || 0;
                        document.getElementById(`player${playerIndex}Accuracy`).textContent = `${stats.accuracy || 0}%`;
                        document.getElementById(`player${playerIndex}Shots`).textContent = stats.shotsFired || 0;
                        playerIndex++;
                    }
                });
            }
            
            const overlay = document.getElementById('afterGameOverlay');
            overlay.style.display = 'block';
            setTimeout(() => {
                overlay.classList.add('active');
            }, 10);
        }

        function updateRematchVotes(data) {
            gameState.rematchVotes = data.votes;
            const btn = document.getElementById('rematchBtn');
            btn.querySelector('span').textContent = `Rematch (${data.votes}/2)`;
        }

        function addProjectile(projectile) {
            const transformCoords = gameState.playerIndex === 1;
            
            // Add shot indicator immediately
            gameState.shotIndicators.push({
                x: transformCoords ? gameState.arenaSize.width - projectile.targetX : projectile.targetX,
                y: transformCoords ? gameState.arenaSize.height - projectile.targetY : projectile.targetY,
                startTime: Date.now(),
                duration: projectile.flightTime * 1000,
                color: projectile.color || '#ffff00'
            });
        }

        function handleInstantProjectile(projectile) {
            const transformCoords = gameState.playerIndex === 1;
            
            if (projectile.type === 'laser') {
                gameState.laserEffects.push({
                    startX: transformCoords ? gameState.arenaSize.width - projectile.startX : projectile.startX,
                    startY: transformCoords ? gameState.arenaSize.height - projectile.startY : projectile.startY,
                    endX: transformCoords ? gameState.arenaSize.width - projectile.endX : projectile.endX,
                    endY: transformCoords ? gameState.arenaSize.height - projectile.endY : projectile.endY,
                    color: projectile.color,
                    startTime: Date.now(),
                    duration: 200
                });
            }
        }

        function handlePowerupConfirmed(data) {
            const localPlayer = gameState.players[gameState.localPlayerId];
            if (localPlayer) {
                localPlayer.points = data.newPoints;
                localPlayer.usedPowerups = new Set(data.usedPowerups);
            }
            gameState.pendingPowerup = null;
            updateUI();
        }

        function updateUI() {
            const localPlayer = gameState.players[gameState.localPlayerId];
            if (!localPlayer) return;

            document.getElementById('yourHealth').style.width = 
                `${(localPlayer.health / config.player.maxHealth) * 100}%`;
            document.getElementById('yourPoints').textContent = localPlayer.points || 0;

            // Update powerup availability - Fixed the crash bug
            [1, 2, 3].forEach(num => {
                const el = document.getElementById(`powerup${num}`);
                if (!el) return;
                
                if (localPlayer.usedPowerups && localPlayer.usedPowerups.has(num)) {
                    el.className = 'powerup-item used';
                } else if ((localPlayer.points || 0) >= 20) {
                    el.className = 'powerup-item available';
                } else {
                    el.className = 'powerup-item';
                }
            });
        }

        // Game Loop
        function gameLoop() {
            if (!gameState.inGame || gameState.countdownActive) return;

            const currentTime = Date.now();
            const deltaTime = (currentTime - gameState.lastUpdateTime) / 1000;
            gameState.lastUpdateTime = currentTime;

            handleInput(deltaTime);
            updateCamera(deltaTime);
            updateEffects(deltaTime);
            render();
            renderMinimap();

            requestAnimationFrame(gameLoop);
        }

        function handleInput(deltaTime) {
            const localPlayer = gameState.players[gameState.localPlayerId];
            if (!localPlayer || !socket || socket.readyState !== WebSocket.OPEN) return;

            let dx = 0, dy = 0;
            if (gameState.keys['w'] || gameState.keys['W']) dy = -1;
            if (gameState.keys['s'] || gameState.keys['S']) dy = 1;
            if (gameState.keys['a'] || gameState.keys['A']) dx = -1;
            if (gameState.keys['d'] || gameState.keys['D']) dx = 1;

            // Transform input for mirrored perspective
            if (gameState.playerIndex === 1) {
                dx = -dx;
                dy = -dy;
            }

            if (dx !== 0 || dy !== 0) {
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                dx /= magnitude;
                dy /= magnitude;

                socket.send(JSON.stringify({
                    type: 'move',
                    dx: dx,
                    dy: dy,
                    deltaTime: deltaTime
                }));
            }

            // Send aim update with transformed coordinates
            const transformCoords = gameState.playerIndex === 1;
            const aimX = transformCoords ? 
                gameState.arenaSize.width - gameState.worldMousePos.x : 
                gameState.worldMousePos.x;
            const aimY = transformCoords ? 
                gameState.arenaSize.height - gameState.worldMousePos.y : 
                gameState.worldMousePos.y;
            
            socket.send(JSON.stringify({
                type: 'aim',
                mouseX: aimX,
                mouseY: aimY
            }));
        }

        function updateCamera(deltaTime) {
            const localPlayer = gameState.players[gameState.localPlayerId];
            if (!localPlayer) return;

            gameState.camera.targetX = localPlayer.x;
            gameState.camera.targetY = localPlayer.y;

            gameState.camera.x += (gameState.camera.targetX - gameState.camera.x) * config.camera.smoothness;
            gameState.camera.y += (gameState.camera.targetY - gameState.camera.y) * config.camera.smoothness;
        }

        function updateEffects(deltaTime) {
            const now = Date.now();
            
            // Update explosions
            gameState.explosions = gameState.explosions.filter(explosion => 
                now - explosion.startTime < explosion.duration
            );
            
            // Update laser effects
            gameState.laserEffects = gameState.laserEffects.filter(laser => 
                now - laser.startTime < laser.duration
            );
            
            // Update shot indicators
            gameState.shotIndicators = gameState.shotIndicators.filter(indicator => 
                now - indicator.startTime < indicator.duration
            );

            // Update projectiles
            gameState.projectiles = gameState.projectiles.filter(proj => {
                proj.x += proj.vx * deltaTime;
                proj.y += proj.vy * deltaTime;
                
                return proj.x >= 0 && proj.x <= gameState.arenaSize.width &&
                       proj.y >= 0 && proj.y <= gameState.arenaSize.height;
            });
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(canvas.width / 2 - gameState.camera.x, canvas.height / 2 - gameState.camera.y);

            // Draw arena
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, gameState.arenaSize.width, gameState.arenaSize.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= gameState.arenaSize.width; x += 100) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, gameState.arenaSize.height);
                ctx.stroke();
            }
            for (let y = 0; y <= gameState.arenaSize.height; y += 100) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(gameState.arenaSize.width, y);
                ctx.stroke();
            }

            // Draw covers
            ctx.fillStyle = config.cover.color;
            gameState.covers.forEach(cover => {
                ctx.fillRect(cover.x, cover.y, cover.width, cover.height);
            });

            // Draw explosions
            gameState.explosions.forEach(explosion => {
                const age = (Date.now() - explosion.startTime) / explosion.duration;
                const radius = explosion.radius * (1 + age * 0.5);
                const alpha = 1 - age;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });

            // Draw laser effects
            gameState.laserEffects.forEach(laser => {
                const age = (Date.now() - laser.startTime) / laser.duration;
                const alpha = 1 - age;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = laser.color;
                ctx.lineWidth = 3 + (1 - age) * 5;
                ctx.shadowBlur = 20;
                ctx.shadowColor = laser.color;
                
                ctx.beginPath();
                ctx.moveTo(laser.startX, laser.startY);
                ctx.lineTo(laser.endX, laser.endY);
                ctx.stroke();
                ctx.restore();
            });

            // Draw shot indicators
            gameState.shotIndicators.forEach(indicator => {
                const age = (Date.now() - indicator.startTime) / indicator.duration;
                const timeLeft = Math.max(0, (1 - age) * indicator.duration / 1000);
                
                ctx.save();
                ctx.strokeStyle = indicator.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8;
                
                // Draw countdown circle
                ctx.beginPath();
                ctx.arc(indicator.x, indicator.y, 20, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw time text
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(timeLeft.toFixed(1), indicator.x, indicator.y);
                
                ctx.restore();
            });

            // Draw players
            Object.values(gameState.players).forEach(player => {
                if (!player.visible && !player.isLocal) return;
                
                const color = player.isLocal ? '#4CAF50' : '#f44336';
                drawTank(player, color);
                drawHealthBar(player);
                
                if (player.reloading && player.reloadProgress !== undefined) {
                    drawReloadIndicator(player.x, player.y, player.reloadProgress);
                }
            });

            // Draw projectiles
            gameState.projectiles.forEach(proj => {
                ctx.fillStyle = proj.color || '#ffff00';
                ctx.shadowBlur = 10;
                ctx.shadowColor = proj.color || '#ffff00';
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, config.projectile.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // Draw aiming line
            const localPlayer = gameState.players[gameState.localPlayerId];
            if (localPlayer) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(localPlayer.x, localPlayer.y);
                ctx.lineTo(gameState.worldMousePos.x, gameState.worldMousePos.y);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();

            // Draw fog of war
            drawFogOfWar();

            // Draw crosshair
            drawCrosshair();
        }

        function drawTank(player, color) {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.rotation || 0);

            ctx.fillStyle = color;
            ctx.fillRect(-config.player.size/2, -config.player.size/2, 
                        config.player.size, config.player.size);

            ctx.fillStyle = '#333';
            ctx.fillRect(0, -5, config.player.size, 10);

            if (player.shield && player.shield > 0) {
                ctx.strokeStyle = config.powerups.shield.color;
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(0, 0, config.player.size * 1.2, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawHealthBar(player) {
            const barWidth = 40;
            const barHeight = 6;
            const yOffset = config.player.size + 15;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(player.x - barWidth/2, player.y - yOffset, barWidth, barHeight);
            
            const healthPercent = player.health / config.player.maxHealth;
            ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : '#f44336';
            ctx.fillRect(player.x - barWidth/2, player.y - yOffset, 
                        barWidth * healthPercent, barHeight);
        }

        function drawReloadIndicator(x, y, progress) {
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(x, y, config.player.size + 10, 
                   -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * progress));
            ctx.stroke();
            ctx.restore();
        }

        function drawFogOfWar() {
            fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);
            
            if (gameState.visiblePoints.length === 0) return;
            
            fogCtx.save();
            fogCtx.translate(fogCanvas.width / 2 - gameState.camera.x, 
                            fogCanvas.height / 2 - gameState.camera.y);
            
            // Draw darkness
            fogCtx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            fogCtx.fillRect(0, 0, gameState.arenaSize.width, gameState.arenaSize.height);
            
            // Cut out visible area
            const localPlayer = gameState.players[gameState.localPlayerId];
            if (localPlayer) {
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.beginPath();
                fogCtx.moveTo(localPlayer.x, localPlayer.y);
                gameState.visiblePoints.forEach(point => {
                    fogCtx.lineTo(point.x, point.y);
                });
                fogCtx.closePath();
                fogCtx.fill();
            }
            
            fogCtx.restore();
        }

        function drawCrosshair() {
            ctx.save();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            
            const x = gameState.mousePos.x;
            const y = gameState.mousePos.y;
            
            ctx.beginPath();
            ctx.moveTo(x - 15, y);
            ctx.lineTo(x - 5, y);
            ctx.moveTo(x + 5, y);
            ctx.lineTo(x + 15, y);
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x, y - 5);
            ctx.moveTo(x, y + 5);
            ctx.lineTo(x, y + 15);
            ctx.stroke();

            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function renderMinimap() {
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, 200, 200);
            
            const scale = 200 / Math.max(gameState.arenaSize.width, gameState.arenaSize.height);
            
            // Draw covers
            minimapCtx.fillStyle = '#444';
            gameState.covers.forEach(cover => {
                minimapCtx.fillRect(
                    cover.x * scale,
                    cover.y * scale,
                    cover.width * scale,
                    cover.height * scale
                );
            });
            
            // Draw players
            Object.values(gameState.players).forEach(player => {
                if (!player.visible && !player.isLocal) return;
                
                minimapCtx.fillStyle = player.isLocal ? '#4CAF50' : '#f44336';
                minimapCtx.beginPath();
                minimapCtx.arc(player.x * scale, player.y * scale, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            });
        }

        // Event Listeners
        document.getElementById('createLobby').addEventListener('click', () => {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                showError('Keine Verbindung zum Server');
                return;
            }

            const playerName = document.getElementById('playerName').value || 'Spieler';
            socket.send(JSON.stringify({
                type: 'createLobby',
                playerName: playerName
            }));
        });

        document.getElementById('joinLobby').addEventListener('click', () => {
            const code = document.getElementById('lobbyCode').value;
            if (!code) {
                showError('Bitte Lobby-Code eingeben');
                return;
            }
            
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                showError('Keine Verbindung zum Server');
                return;
            }

            const playerName = document.getElementById('playerName').value || 'Spieler';
            socket.send(JSON.stringify({
                type: 'joinLobby',
                lobbyCode: code,
                playerName: playerName
            }));
        });

        document.getElementById('refreshLobbies').addEventListener('click', () => {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                showError('Keine Verbindung zum Server');
                return;
            }
            socket.send(JSON.stringify({ type: 'getLobbies' }));
        });

        document.getElementById('leaveLobby').addEventListener('click', () => {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            socket.send(JSON.stringify({ type: 'leaveLobby' }));
            document.getElementById('waitingRoom').style.display = 'none';
        });

        document.getElementById('rematchBtn').addEventListener('click', () => {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                showError('Keine Verbindung zum Server');
                return;
            }
            socket.send(JSON.stringify({ type: 'rematchVote' }));
        });

        document.getElementById('newLobbyBtn').addEventListener('click', () => {
            location.reload();
        });

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;

            if (!gameState.inGame || gameState.countdownActive) return;

            // Powerups
            if (e.key >= '1' && e.key <= '3') {
                const powerupNum = parseInt(e.key);
                const localPlayer = gameState.players[gameState.localPlayerId];
                
                if (localPlayer && localPlayer.usedPowerups && 
                    !localPlayer.usedPowerups.has(powerupNum) && 
                    localPlayer.points >= 20 && !gameState.pendingPowerup) {
                    
                    gameState.pendingPowerup = powerupNum;
                    socket.send(JSON.stringify({
                        type: 'usePowerup',
                        powerup: powerupNum
                    }));
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        // Mouse input
        document.addEventListener('mousemove', (e) => {
            gameState.mousePos.x = e.clientX;
            gameState.mousePos.y = e.clientY;
            
            gameState.worldMousePos.x = e.clientX + gameState.camera.x - canvas.width / 2;
            gameState.worldMousePos.y = e.clientY + gameState.camera.y - canvas.height / 2;
        });

        document.addEventListener('click', (e) => {
            if (!gameState.inGame || gameState.countdownActive || 
                !socket || socket.readyState !== WebSocket.OPEN) return;
            
            const localPlayer = gameState.players[gameState.localPlayerId];
            if (localPlayer && !localPlayer.reloading) {
                const transformCoords = gameState.playerIndex === 1;
                const targetX = transformCoords ? 
                    gameState.arenaSize.width - gameState.worldMousePos.x : 
                    gameState.worldMousePos.x;
                const targetY = transformCoords ? 
                    gameState.arenaSize.height - gameState.worldMousePos.y : 
                    gameState.worldMousePos.y;
                
                socket.send(JSON.stringify({
                    type: 'shoot',
                    targetX: targetX,
                    targetY: targetY
                }));
            }
        });
    </script>
</body>
</html>
